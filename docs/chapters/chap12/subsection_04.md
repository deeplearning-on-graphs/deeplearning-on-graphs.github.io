[メインページ](../../index.markdown)

[章目次](./chap12.md)
## 12.4. サイバーセキュリティ・データマイニング

インターネットの利用者が増えるにつれて，コンピュータや通信システムに対する新たな脆弱性や攻撃手段が日々発見されている． これらの変化とその流動性は，従来のセキュリティ手法に大きな課題をもたらしている． そもそもデータマイニングは「データから行動に移せるパターンを発見する」ものであるため，サイバーセキュリティの課題にも対応すことができるといえる． 特に，サイバーセキュリティデータをグラフとして表現可能であることを考慮に入れると，GNNはスパム送信者の検出やフェイクニュースの検出など，サイバーセキュリティデータの様々な面において有効に活用されている．

### 悪意のあるアカウントの検出

サイバー攻撃者は，悪意のあるアカウントを使ってスパムメッセージを拡散することで，メールシステム，SNS，ECサイト，金融系プラットフォームなどの大規模オンラインサービスへの攻撃を狙う． これらのサイバー攻撃はどのオンラインサービスにとっても脅威であり，状況によっては巨大な経済的損失を招きかねない． そのため，効果的な悪意のあるアカウントの検出は重要であり，GNNモデルは，こうしたアカウントの検出タスクを支援するために利用されている．

Lie *et al*.(2018b)では，悪意のあるアカウントの特徴に関して以下の2パターンを観測している．

同じ攻撃者に由来する悪意のあるアカウント

:   その攻撃者は限られたリソースしか持たないから，同じデバイスや共通のデバイス群でサインアップやログインを行う傾向がある．

同じグループに由来する悪意のあるアカウント

:   まとまって行動を行う傾向がある．つまり，こうしたアカウント群は一度のタイミングにサインアップやログインを行う．

上記から得られる示唆より，アカウントとデバイスに基づいたグラフが構築され，悪意のあるアカウントの検出タスクは，このグラフ上に対する半教師あり二値分類タスクとして扱われることになる． このタスクが目指すのは「与えられたアカウントが悪意があるものかどうかを判断する」ことである． ここから，まずはこのグラフの構築過程を説明し，その後，悪意のあるアカウントの検出のためにGNNをどのように活用できるかについて議論していく．

#### アカウントとデバイスに基づいたグラフの構築

悪意のあるアカウントの検出タスクには，アカウントとデバイスという2種類のオブジェクトが関わっている． ここでの"デバイス"という概念は，IPアドレスや電話番号を含む非常に一般的なものである． これらデバイスの集合を $\symcal{D}$ とおく． ここでは，アカウントとデバイスを合わせた $N$ 個のノードが存在すると想定する． 特定のデバイスでアカウントの活動（例えば，サインアップやログインなど）が確認された場合，そのアカウントとデバイスの間にエッジが存在するとみなす． このようにして構築されたグラフは， $\symcal{G}=\left\\{\symcal{V},\symcal{E}\right\\}$ と表すことができる（ $\symcal{V}$ と $\symcal{E}$ は，それぞれノード集合とエッジ集合を表す）．  $\symcal{V}$ 内のノード間に存在する関係は，隣接行列 $\symbf{A}$ によっても記述できる． また， $\symcal{G}(d)$ を，全ノードを含むがエッジはタイプ $d\in\symcal{D}$ のデバイスに関連するものだけから構成される部分グラフとすると，グラフ $\symcal{G}$ から， $\|\symcal{D}\|$ 個の部分グラフ $\left\\{\symcal{G}^{(d)}=\left\\{\symcal{V},\symcal{E}^{(d)}\right\\}\right\\}$ が抽出できる（ $\symbf{A}^{(d)}$ は部分グラフ $\symcal{G}(d)$ の隣接行列）．

各ノード $v_i\in \symcal{V}$ には特徴ベクトル $x_i\in \mathbb{R}^{(p+\|\symcal{D}\|)}$ が関連付けられる． 具体的には， $\symbf{x}\_i$ の最初の $p$ 個の要素は，連続する $p$ 個の期間における活動のカウントを示している． Lie *et al*.(2018b)では，期間を $p=168$ に分割して，各時間帯を1時間ごとに設定している． また， $\symbf{x}\_i$ の最後の $\|\symcal{D}\|$ 個の要素はデバイスの種類に対応している． もし $v_i$ ノードがデバイスであればこの部分はワンホットベクトルとして符号化し， $v_i$ ノードがアカウントであれば，この部分の要素はすべて $0$ となる．

#### GNNによる悪意あるアカウントの検出

GNNはノードの特徴量を洗練するから，悪意のあるアカウント検出（より広範囲に言えば二値分類）を行うために活用される． 半教師あり分類タスクの定式化は5.5.1節と同じである． したがって，ここでは主にノード特徴量の学習プロセスを紹介する． 具体的には，以下のように，本タスク特化のグラフフィルタを導入する：  

$$
 \symbf{F}^{(l)} = \sigma\left(\symbf{X}\symbf{\Theta}^{(l-1)} + \dfrac{1}{\|\symcal{D}\|}\sum_{d\in\symcal{D}}\symbf{A}^{(d)}\symbf{F}^{(l-1)}\symbf{\Theta}^{(l-1)}_{(d)}\right) $$


  ここで， $\symbf{X}$ は全ノードの入力特徴量を表し， $\symbf{F}^{(l)}$ は $l$ 番目のグラフフィルタリング層を経た後に得られる隠れ表現で（ $\symbf{F}^{(0)} = \symbf{0}$ ）， $\left\\{\symbf{\Theta}^{(l-1)},\symbf{\Theta}^{(l-1)}\_{(d)}\right\\}$ は学習対象のパラメータである． なお，グラフフィルタリング操作は5.3.2節で紹介したものとは異なり，「各グラフフィルタリング層において入力特徴量 $\symbf{X}$ が使われている」点に注意しよう． これにより， $\symbf{X}$ によって符号化されるアカウントの活動パターンをより良く保持することができる [^4]．

 $L$ 層のグラフフィルタリング操作の後，特徴量 $\symbf{F}^{(L)}$ は二値分類を行うために使用される． 同じ攻撃者に由来する悪意のあるアカウントは，同じデバイス群とエッジを形成する傾向があり，グラフフィルタリングプロセスはそれのアカウントが類似した特徴量を持つようにはたらく． 一方で，アカウント自体の活動パターンは入力特徴量 $\symbf{X}$ によって捉えられる． このように，（前述した）悪意のあるアカウントの特徴に関する2つのパターンは，GNNモデルによって捉えることができ，悪意のあるアカウントの検出タスクに役立つ．

### フェイクニュース検出

オンラインのソーシャルメディアはその手軽さと即時性のため，人々がニュースを得るための重要な情報源となっている． しかし，これらのプラットフォームは非常に便利で効率的である一方で，これまで以上にフェイクニュースの拡散リスクを抱えている． フェイクニュースは多くの不都合な結果をもたらし，社会的な問題や大規模な経済的損失を引き起こすこともある． そのため，フェイクニュースを検出するタスクは，このようなニュースがソーシャルメディアを通じて拡散するのを防ぐためには大変重要なタスクとなってくる． オンラインのソーシャルメディアにおける数多くの経験的な証拠から，「フェイクニュースは信頼性の高いニュースとは異なる拡散パターンを持っている」ことが明らかになっている(Vosoughi *et al*., 2018)． この事実はフェイクニュースの検出タスクを容易にする足がかりとなる．

Monti *et al*.(2019)では，各ニュース記事は，その拡散プロセスとTwitterなどのSNSプラットフォームにおける社会的関係を表現するために，グラフとしてモデル化される． フェイクニュースの検出タスクは**グラフの二値分類問題**として扱われ，GNNモデルがその性能向上のために採用されている． 以下ではまず，ニュース記事によるグラフの構成プロセスを説明し，次に，本タスク用に設計されたGNNモデルを簡単に紹介する．

#### ニュース記事に基づいたグラフの構築

ここでは，ニュースの拡散プロセスを例に，各記事に対するグラフの構築プロセスを説明する． 特定の記事 $u$ とそれに言及するツイート $\symcal{T}\_u=\left\\{t^{(1)}\_u,\dots,t^{(N_u)}\_u\right\\}$ が与えられた場合，記事 $u$ はグラフ $\symcal{G}\_u$ として表現することができる． グラフ $\symcal{G}\_u$ は， $\symcal{T}\_u$ の全てのツイートをノードとして，エッジはニュースの拡散プロセスを示すか，またはこれらのツイートしたユーザ間の社会的関係を示すかの2種類を考える． そこで，グラフ $\symcal{G}\_u$ 内でのこの2種類のエッジについて以下で説明する． ここでは，あるツイート $t^{(i)}\_u$ のユーザ(author)を $a(t^{(i)}\_u)$ と表現することとする．

1.ツイートを行うユーザに基づいて定義されるエッジ

:    $t^{(i)}\_u$ と $t^{(j)}\_u$ の2つのツイートの間には， $a(t^{(i)}\_u)$ が $a(t^{i}\_u)$ をフォローしているか，または $a(t^{i}\_u)$ が $a(t^{(i)}\_u)$ をフォローしている場合にエッジを接続させる．

2.SNSを通じたニュース記事 $u$ の拡散に基づいて定義されるエッジ

:   ニュース記事 $u$ が一方から他方へ拡散するとき，2つのツイート $t^{(i)}\_u$ と $t^{(j)}\_u$ の間にエッジを接続させる．

このうち，（2種類目のエッジである）ニュースの拡散経路はVosoughi *et al*.(2018)に従って推定され，これはツイートの日時とそのツイート者の社会的なつながりを考慮して作成される． なお，便宜上，ツイート $t^{(i)}\_u$ の上付き添字がその日時情報を示すと仮定する． すなわち， $i$ より小さい上付き文字を持つすべてのツイートは $t^{(i)}\_u$ より前にツイートされものとし， $i$ より大きい上付き文字を持つツイートは $t^{(i)}\_u$ の後にツイートされたものとする． 以上を踏まえ，特定のツイート $t^{(i)}\_u$ について，その拡散経路を次のように推定する：

-   もし $a(t^{(i)}\_u)$ が，それまでに記事 $u$ についてツイートしたユーザ $\left\\{a(t^{(1)}\_u),\dots,a(t^{(i-1)}\_u)\right\\}$ のうち少なくとも1人をフォローしているなら，そのニュースは $a(t^{(i)}\_u)$ がフォローしているユーザのツイートの中で一番最新のツイートから $t^{(i)}\_u$ へと拡散したと推定する．

-   もし $a(t^{(i)})$ が，それまでに記事 $u$ についてツイートしたユーザ $\left\\{a(t^{(1)}\_u),\dots,a(t^{(i-1)}\_u)\right\\}$ のうち誰もフォローしていない場合，そのニュースは $\left\\{t^{(1)}\_u,\dots,t^{(i-1)}\_u\right\\}$ の中でフォロワー数が最も多いユーザのツイートから $t^{(i)}\_u$ へと拡散したと推定する．

#### グラフ分類タスクとしてのフェイクニュース検出

上述したように，各ニュース記事を使ってグラフを作成し，フェイクニュース検出タスクをグラフに関する二値分類タスクとして扱う． グラフ分類のためのGNNフレームワークは5.5.2節で紹介しており，これをそのまま本タスクに適用することができる． 具体的に，Monti *et al*.(2019)では，ノードの特徴量を洗練させるために2つのグラフフィルタ層を用意しており，その後にグラフ平均プーリング層を置くことでグラフ全体の表現を生成する． 生成されたグラフ表現は，二値分類を行うために使用される．


[メインページ](../../index.markdown)

[章目次](./chap12.md)

[前の節へ](./subsection_03.md) [次の節へ](./subsection_05.md)

[^4]: 訳注：伝統的なグラフフィルタリング操作では，各層の入力として前の層の出力（隠れ表現）のみが使用される．しかし，今回のケースでは，各フィルタリング層で元の入力特徴量 $\symbf{X}$ も考慮に入れている．悪意のあるアカウントの検出のようなタスクでは，アカウントの行動パターンが重要な情報を持っているため，有効な手法である．
